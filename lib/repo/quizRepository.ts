import { z } from 'zod';
import { quiz, questionFeedback } from '@/lib/db/schema'; // Removed 'users'
import { eq, and, sql, desc, count as dslCount } from 'drizzle-orm'; // Removed 'isNull'
import type { RunResult } from 'better-sqlite3'; // Import RunResult for explicit typing
import db from '@/lib/db';

// Schema for the data structure stored in the quiz table's content column
// This should align with the actual structure generated by AI and expected by QuizDataSchema
export const QuizContentSchema = z.object({
  paragraph: z.string(), // Changed from passage
  topic: z.string().optional().nullable(), // Added optional topic
  question: z.string(),
  options: z.object({
    A: z.string(),
    B: z.string(),
    C: z.string(),
    D: z.string(),
  }),
  correctAnswer: z.string(), // Changed from answer
  allExplanations: z.object({
    // Changed from explanation: string
    A: z.string(),
    B: z.string(),
    C: z.string(),
    D: z.string(),
  }),
  relevantText: z.string().optional().nullable(), // Added optional relevantText
});

// Schema for the raw row returned by the database
const QuizRowSchema = z.object({
  id: z.number(),
  language: z.string(),
  level: z.string(),
  content: z.string(), // JSON string in the DB
  createdAt: z.date().nullable(), // Align with Drizzle for nullable timestamp
  questionLanguage: z.string().nullable(),
  userId: z.number().nullable(),
});

export type QuizRow = z.infer<typeof QuizRowSchema>;

// Schema for the fully parsed Quiz object, including parsed content
export const QuizSchema = QuizRowSchema.extend({
  content: QuizContentSchema,
});

export type Quiz = z.infer<typeof QuizSchema>;

// Finds a quiz by its ID
export const findQuizById = (id: number): Quiz | null => {
  try {
    const row: typeof quiz.$inferSelect | undefined = db
      .select()
      .from(quiz)
      .where(eq(quiz.id, id))
      .get();

    if (!row) {
      return null;
    }

    const rowParseResult = QuizRowSchema.safeParse(row);

    if (!rowParseResult.success) {
      console.error(
        `[QuizRepository] Invalid quiz row structure for ID ${id}:`,
        rowParseResult.error.format()
      );
      return null;
    }

    let parsedContent: unknown;
    try {
      parsedContent = JSON.parse(rowParseResult.data.content);
    } catch (jsonError) {
      console.error(`[QuizRepository] Failed to parse quiz content JSON for ID ${id}:`, jsonError);
      return null;
    }

    const contentParseResult = QuizContentSchema.safeParse(parsedContent);
    if (!contentParseResult.success) {
      console.error(
        `[QuizRepository] Invalid quiz content JSON for ID ${id}:`,
        contentParseResult.error.format()
      );
      return null;
    }

    return {
      ...rowParseResult.data,
      content: contentParseResult.data,
    };
  } catch (error) {
    console.error(`[QuizRepository] Error fetching quiz by ID ${id}:`, error);
    throw error;
  }
};

// Creates a new quiz record
export const createQuiz = async (
  language: string,
  level: string,
  questionLanguage: string | null,
  content: object, // Expects the structured content object
  userIdInput?: number | null
): Promise<number> => {
  try {
    const contentJson = JSON.stringify(content);
    const executionResult: RunResult = await db
      .insert(quiz)
      .values({
        language,
        level,
        questionLanguage,
        content: contentJson,
        userId: userIdInput,
      })
      .execute();

    if (typeof executionResult.lastInsertRowid === 'bigint') {
      return Number(executionResult.lastInsertRowid);
    }
    return executionResult.lastInsertRowid;
  } catch (error) {
    console.error('[QuizRepository] Error creating quiz:', error);
    throw error;
  }
};

// Saves a generated exercise (similar to create, but takes JSON string)
export const saveExercise = async (
  passageLanguage: string,
  questionLanguage: string | null,
  level: string,
  contentJson: string, // Expects JSON string directly
  userIdInput: number | null
): Promise<number> => {
  try {
    const executionResult: RunResult = await db
      .insert(quiz)
      .values({
        language: passageLanguage,
        level,
        content: contentJson,
        questionLanguage,
        userId: userIdInput,
      })
      .execute();

    if (typeof executionResult.lastInsertRowid === 'bigint') {
      return Number(executionResult.lastInsertRowid);
    }
    return executionResult.lastInsertRowid;
  } catch (error) {
    console.error('[QuizRepository] Error saving exercise:', error);
    throw error;
  }
};

// Finds a suitable cached quiz, excluding those the user has seen (feedback submitted)
export const findSuitableQuizForUser = (
  passageLanguage: string,
  questionLanguageInput: string, // Renamed to avoid conflict with schema field
  level: string,
  userIdInput: number | null // Renamed to avoid conflict
): Quiz | null => {
  try {
    let row: typeof quiz.$inferSelect | undefined;

    if (userIdInput !== null) {
      // Subquery to get quiz IDs the user has provided feedback for
      const feedbackSubQuery = db
        .select({ quizId: questionFeedback.quizId })
        .from(questionFeedback)
        .where(eq(questionFeedback.userId, userIdInput));

      row = db
        .select()
        .from(quiz)
        .where(
          and(
            eq(quiz.language, passageLanguage),
            eq(quiz.questionLanguage, questionLanguageInput),
            eq(quiz.level, level),
            sql`${quiz.id} NOT IN ${feedbackSubQuery}` // Use NOT IN with subquery
          )
        )
        .orderBy(desc(quiz.createdAt)) // Drizzle schema uses createdAt
        .limit(1)
        .get();
    } else {
      row = db
        .select()
        .from(quiz)
        .where(
          and(
            eq(quiz.language, passageLanguage),
            eq(quiz.questionLanguage, questionLanguageInput),
            eq(quiz.level, level)
          )
        )
        .orderBy(desc(quiz.createdAt)) // Drizzle schema uses createdAt
        .limit(1)
        .get();
    }

    if (!row) {
      return null;
    }

    const rowParseResult = QuizRowSchema.safeParse(row);

    if (!rowParseResult.success) {
      console.error(
        `[QuizRepository] Invalid cached quiz row structure found for ${passageLanguage}/${level}:`,
        rowParseResult.error.format()
      );
      return null;
    }

    let parsedContent: unknown;
    try {
      parsedContent = JSON.parse(rowParseResult.data.content);
    } catch (jsonError) {
      console.error(
        `[QuizRepository] Failed to parse cached quiz content JSON for ID ${rowParseResult.data.id}:`,
        jsonError
      );
      return null;
    }
    const contentParseResult = QuizContentSchema.safeParse(parsedContent);
    if (!contentParseResult.success) {
      console.error(
        `[QuizRepository] Invalid cached quiz content JSON found for ${passageLanguage}/${level}, ID ${rowParseResult.data.id}:`,
        contentParseResult.error.format()
      );
      return null;
    }

    return {
      ...rowParseResult.data,
      content: contentParseResult.data,
    };
  } catch (error) {
    console.error('[QuizRepository] Error finding suitable quiz:', error);
    throw error;
  }
};

// Counts existing cached exercises matching criteria
export const countExercises = (
  passageLanguage: string,
  questionLanguageInput: string, // Renamed
  level: string
): number => {
  try {
    const result = db
      .select({ value: dslCount() }) // Drizzle's count()
      .from(quiz)
      .where(
        and(
          eq(quiz.language, passageLanguage),
          eq(quiz.questionLanguage, questionLanguageInput),
          eq(quiz.level, level)
        )
      )
      .get(); // .get() returns the single row with the count

    return result?.value ?? 0;
  } catch (error) {
    console.error('[QuizRepository] Error counting exercises:', error);
    throw error;
  }
};
